# NEW OD 题库
## OD3 字符串重新排列  流
给定一个字符串s，s包括以空格分隔的若干个单词，请对s进行如下处理后输出：
1、单词内部调整：对每个单词字母重新按字典序排序
2、单词间顺序调整：
1）统计每个单词出现的次数，并按次数降序排列
2）次数相同，按单词长度升序排列
3）次数和单词长度均相同，按字典升序排列

请输出处理后的字符串，每个单词以一个空格分隔。

解法：流 + HashMap记录出现次数
## 0D6 不含101的数 暴力 / DP
题目描述
小明在学习二进制时，发现了一类不含 101的数，也就是：

将数字用二进制表示，不能出现 101 。
现在给定一个整数区间 [l,r] ，请问这个区间包含了多少个不含 101 的数？

输入描述
输入的唯一一行包含两个正整数 l， r（ 1 ≤ l ≤ r ≤ 10^9）。

输出描述
输出的唯一一行包含一个整数，表示在 [l,r] 区间内一共有几个不含 101 的数。
解法： String.toBinaryString() 方法可暴力解出；按位dp可优化

## OD8
题目描述
给定一个数组nums，将元素分为若干个组，使得每组和相等，求出满足条件的所有分组中，组内元素和的最小值。

输入描述
第一行输入 m
接着输入m个数，表示此数组nums
数据范围：1<=m<=50, 1<=nums[i]<=50

输出描述
最小拆分数组和
解法：回溯 / 二分查找
平分组总和最少，能分成多少组sum / count，再看能不能分成这几组

## OD39 DP
题目描述
小明每周上班都会拿到自己的工作清单，工作清单内包含 n 项工作，每项工作都有对应的耗时时间（单位 h）和报酬，工作的总报酬为所有已完成工作的报酬之和，那么请你帮小明安排一下工作，保证小明在指定的工作时间内工作收入最大化。

输入描述
输入的第一行为两个正整数 T，n。
T 代表工作时长（单位 h， 0 < T < 1000000），
n 代表工作数量（ 1 < n ≤ 3000）。
接下来是 n 行，每行包含两个整数 t，w。
t 代表该工作消耗的时长（单位 h， t > 0），w 代表该项工作的报酬。

输出描述
输出小明指定工作时长内工作可获得的最大报酬。
解法：经典01背包问题，DP即可

## LC698 花费为和相同的子集合 回溯
给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。
详见：https://blog.csdn.net/qfc_128220/article/details/127761308
解法：回溯，用桶来看是否能装下，先排序，再依次放，知道球放完为止
参数：原始数组、分为几组、当前球的索引、目标总和、桶的数组

## LC416 DP / 回溯
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
解法：嗯 回溯
dp：dp[i][j] 选择前i个产品，其和能否达到j

## OD8 等和子数组最小和 回溯
给定一个数组nums，将元素分为若干个组，使得每组和相等，求出满足条件的所有分组中，组内元素和的最小值。
解法：回溯
最多能分为n组，n从最大个数依次递减

## OD8_2 最大平分数组
给定一个数组nums，可以将元素分为若干个组，使得每组和相等，求出满足条件的所有分组中， 最大的平分组个数。
解法：同上，返回的是组数
注：不从大到小排不行

## OD24 星际篮球争霸赛 回溯
在星球争霸篮球赛对抗赛中，最大的宇宙战队希望每个人都能拿到MVP，MVP的条件是单场最高分得分获得者。
可以并列所以宇宙战队决定在比赛中尽可能让更多队员上场，并且让所有得分的选手得分都相同，
然而比赛过程中的每1分钟的得分都只能由某一个人包揽。
解法：同上，在一定的序列中找到最多等和序列
需注意：必须从大到小进行排列

## OD26 日志首次上报最多积分 dp
日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。

如果上报太频繁，会对服务端造成压力;
如果上报太晚，会降低用户的体验；
如果一次上报的条数太多，会导致超时失败。
为此，项目组设计了如下的上报策略：

每成功上报一条日志，奖励1分
每条日志每延迟上报1秒，扣1分
积累日志达到100条，必须立即上报
给出日志序列，根据该规则，计算首次上报能获得的最多积分数。
解法：
dp[i] 在第i时刻上报能获得的最大分数
dp[i] 和 dp[i - 1]  : 1 累积到100，必须提交， 2 未累积到100，提交当前的，扣除前所有时刻的， 3 前一时刻的最大值
扣分单独算

## OD31 最多获得的短信条数 dp
某云短信厂商，为庆祝国庆，推出充值优惠活动。
现在给出客户预算，和优惠售价序列，求最多可获得的短信总条数。
输入描述
第一行客户预算M，其中 0 ≤ M ≤ 10^6
第二行给出售价表， P1, P2, … Pn , 其中 1 ≤ n ≤ 100 ,
Pi为充值 i 元获得的短信条数。1 ≤ Pi ≤ 1000 , 1 ≤ n ≤ 100

输出描述
最多获得的短信条数
解法：
dp[i][j] 用j钱，买前i个物品，可重复，最多能得到的价值
买不起当前的，dp[i][j] = dp[i - 1][j]
买得起当前的，买当前的：dp[i-1][j - table[i]] + 当前值 和 不买的取最大值dp[i - 1][j] 这是01背包
完全背包：得先初始化买第一个物品的所有的钱的情况,这里是不同的地方，然后先遍历物品，再遍历钱都可以
**待优化为一维dp数组！！！**

## OD45 查找重复代码 dp
小明负责维护项目下的代码，需要查找出重复代码，用以支撑后续的代码优化，请你帮助小明找出重复的代码。
重复代码查找方法：以字符串形式给定两行代码（字符串长度 1 < length <= 100，由英文字母、数字和空格组成），找出两行代码中的最长公共子串。
注：如果不存在公共子串，返回空字符串

输入描述
输入的参数text1, text2分别表示两行代码

输出描述
输出任一最长公共子串

解法：
1. 双指针，但要注意边界条件，即两个字符串分别遍历到最后一个位置
2. dp
dp[i][j] 字符串a的前i个字符和字符串b的前j个字符，最大的字串数量 
正斜上方表示两个字符串的上一个字符是否相同

## OD31 组装新的数组 回溯
给你一个整数M和数组N，N中的元素为连续整数，要求根据N中的元素组装成新的数组R，组装规则：

R中元素总和加起来等于M
R中的元素可以从N中重复选取
R中的元素最多只能有1个不在N中，且比N中的数字都要小（不能为负数）
输入描述
第一行输入是连续数组N，采用空格分隔
第二行输入数字M

输出描述
输出的是组装办法数量，int类型
解法：回溯，可重复，不需要去重

## OD23 优雅子数组 dp/双指针
题目描述
如果一个数组中出现次数最多的元素出现大于等于K次，被称为 k-优雅数组 ，k也可以被称为优雅阈值。
例如，数组1，2，3，1、2，3，1，它是一个3-优雅数组，因为元素1出现次数大于等于3次，
数组[1, 2, 3, 1, 2]就不是一个3-优雅数组，因为其中出现次数最多的元素是1和2，只出现了2次。

给定一个数组A和k，请求出A有多少子数组是k-优雅子数组。

子数组是数组中一个或多个连续元素组成的数组。

例如，数组[1,2,3,4]包含10个子数组，分别是：
[1], [1,2], [1,2,3], [1,2,3,4], [2], [2,3], [2,3,4], [3], [3, 4], [4]。

输入描述
第一行输入两个数字，以空格隔开，含义是：A数组长度 k值

第二行输入A数组元素，以空格隔开

输出描述
输出A有多少子数组是k-优雅子数组
解法：
或者直接暴力双指针也可
动态规划，用hashtable代替dp，双指针，右指针不用回退到左子针位置，且各字符数量已经放在hashtable中
详见https://fcqian.blog.csdn.net/article/details/128385825

## OD63 递增字符串 dp
题目描述
定义字符串完全由 ‘A’ 和 ‘B’组成，当然也可以全是’A’或全是’B’。如果字符串从前往后都是以字典序排列的，那么我们称之为严格递增字符串。
给出一个字符串s，允许修改字符串中的任意字符，即可以将任何的’A’修改成’B’，也可以将任何的’B’修改成’A’，
求可以使s满足严格递增的最小修改次数。

0 < s的长度 < 100000。

输入描述
输入一个字符串： “AABBA”

输出描述
输出：1
dp：
前i为a，剩余为b，遍历第一到最后
i左边全为a，需要：i - i左边已有的a个数
i右边全为b，需要：i右边剩余的a的个数
总共所需的变化次数：i + 总共的 a -前i个已有a * 2；
dp[i]为前i个实际有多少个苹果，可以只用一个变量代替数组

## OD28_2 查找充电设备组合 DP/回溯
题目描述
某个充电站，可提供n个充电设备，每个充电设备均有对应的输出功率。任意个充电设备组合的输出功率总和，均构成功率集合P的1个元素。功率集合P的最优元素，表示最接近充电站最大输出功率p_max的元素。

输入描述
输入为3行：

第1行为充电设备个数n
第2行为每个充电设备的输出功率
第3行为充电站最大输出功率p_max
输出描述
功率集合P的最优元素

备注
充电设备个数 n > 0
最优元素必须小于或等于充电站最大输出功率p_max
就是求最大不超过max的子集的和

解法：
回溯，记录最大值就行
dp，[i][j] 容量为j的前i个物品能产生的最大价值

## OD61 微服务的集成测试 回溯
题目描述
现在有n个容器服务，服务的启动可能有一定的依赖性（有些服务启动没有依赖），其次服务自身启动加载会消耗一些时间。

给你一个 n x n 的二维矩阵useTime，其中

useTime[i][i]=10 表示服务i自身启动加载需要消耗10s
useTime[i][j] = 1 表示服务i启动依赖服务j启动完成
useTime[i][k]=0  表示服务i启动不依赖服务k
其实 0<= i，j，k < n。

服务之间启动没有循环依赖（不会出现环），若想对任意一个服务i进行集成测试（服务i自身也需要加载），求最少需要等待多少时间。

输入描述
第一行输入服务总量 n，
之后的 n 行表示服务启动的依赖关系以及自身启动加载耗时
最后输入 k 表示计算需要等待多少时间后可以对服务 k 进行集成测试

其中 1 <= k <=n，1<=n<=100

输出描述
最少需要等待多少时间(s)后可以对服务 k 进行集成测试
解答： 
解答不了

## OD19 对称美学
题目描述
对称就是最大的美学，现有一道关于对称字符串的美学。已知：

第1个字符串：R
第2个字符串：BR
第3个字符串：RBBR
第4个字符串：BRRBRBBR
第5个字符串：RBBRBRRBBRRBRBBR
相信你已经发现规律了，没错！就是第 i 个字符串 = 第 i - 1 号字符串取反 + 第 i - 1 号字符串；

取反（R->B, B->R）;

现在告诉你n和k，让你求得第n个字符串的第k个字符是多少。（k的编号从0开始）

输入描述
第一行输入一个T，表示有T组用例；

解析来输入T行，每行输入两个数字，表示n，k

1 ≤ T ≤ 100；
1 ≤ n ≤ 64；
0 ≤ k ＜ 2^(n-1)；
输出描述
输出T行表示答案；
输出 "blue" 表示字符是B；
输出 "red" 表示字符是R。
解法：找规律
第n个字串的后半部分等于第n-1个字串的相同位置  get(n-1, k - 2^(n-2))
第n个字串的前半部分等于第n-1个字串的相同位置取反 k <= 2^(n-2) ，则相当于 get(n-1, k) 的颜色取反
注：思考应当在思维清醒的时候进行

## OD32 硬件产品销售方案 回溯
题目描述
某公司目前推出了AI开发者套件，AI加速卡，AI加速模块，AI服务器，智能边缘多种硬件产品，每种产品包含若干个型号。
现某合作厂商要采购金额为amount元的硬件产品搭建自己的AI基座。
例如当前库存有N种产品，每种产品的库存量充足，给定每种产品的价格，记为price（不存在价格相同的产品型号）。
请为合作厂商列出所有可能的产品组合。

输入描述
输入包含采购金额amount和产品价格列表price。第一行为amount，第二行为price，例如：

500
[100, 200, 300, 500]

输出描述
输出为组合列表。例如：

[[100, 100, 100, 100, 100], [100, 100, 100, 200], [100, 100, 300], [100, 200, 200], [200, 300], [500]]

解法：
回溯，通过排序，则不需要去重
可以剪枝，找到第一个不满足的，后面就都不用搜索了，但暂未实现

## OD33_2 九宫格 回溯
题目描述
九宫格是一款广为流传的游戏，起源于河图洛书。
游戏规则是：1到9九个数字放在3×3的格子中，要求每行、每列以及两个对角线上的三数之和都等于15.
在金麻名著《射雕英雄传》中黃蓉曾给九宫格的一种解法，口诀：戴九恩一，左三右七，二四有肩，八六为足，五居中央。解法如图所示。

现在有一种新的玩法，给九个不同的数字，将这九个数字放在3×3的格子中，要求每行、每列以及两个对角线上的三数之积相等（三阶积幻方）。其中一个三阶幻方如图：
解释：每行、每列以及两个对角线上的三数之积相等，都为216。请设计一种算法，将给定的九个数宇重新排列后，使其满足三阶积幻方的要求。
排列后的九个数宇中：第1-3个数字为方格的第一行，第4-6个数宇为方格的第二行，第7-9个数字为方格的第三行。

输入描述
九个不同的数宇，每个数字之间用空格分开。
0＜数字<10^7。0<排列后满足要求的每行、每列以及两个对角线上的三数之积 ＜ 2^31-1。

输出描述
九个数字所有满足要求的排列，每个数字之间用空格分开。每行输出一个满足要求的排列。
要求输出的排列升序排序，即：对于排列A (A1.A2.A3…A9)和排列B(B1,B2,B3…B9），从排列的第1个数字开始，遇到Ai<Bi，则排列A<排列B （1<=j<=9)。

说明：用例保证至少有一种排列组合满足条件。

解法：暴力排列所有组合，判断每个组合是否满足；直接最小排序
得用used数组表示是否使用过 用 boolean[]
需要剪枝